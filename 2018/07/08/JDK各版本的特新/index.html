<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">

<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
    
  
  <link href="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






  

<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JDK新特性," />





  <link rel="alternate" href="/atom.xml" title="十四心" type="application/atom+xml" />






<meta name="description" content="JDK 1.0开发代号为Oak（橡树），于1996-01-23发行。 JDK 1.1于1997-02-19发行。引入的新特性包括：引入JDBC（Java Database Connectivity）；支持内部类；引入Java Bean；引入RMI（Remote Method Invocation）；引入反射（仅用于内省）。 JDK 1.2开发代号为Playground（操场），于1998-12-0">
<meta name="keywords" content="JDK新特性">
<meta property="og:type" content="article">
<meta property="og:title" content="JDK各版本新特性介绍">
<meta property="og:url" content="http://github.lushunde.com/2018/07/08/JDK各版本的特新/index.html">
<meta property="og:site_name" content="十四心">
<meta property="og:description" content="JDK 1.0开发代号为Oak（橡树），于1996-01-23发行。 JDK 1.1于1997-02-19发行。引入的新特性包括：引入JDBC（Java Database Connectivity）；支持内部类；引入Java Bean；引入RMI（Remote Method Invocation）；引入反射（仅用于内省）。 JDK 1.2开发代号为Playground（操场），于1998-12-0">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-07-07T18:30:19.334Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JDK各版本新特性介绍">
<meta name="twitter:description" content="JDK 1.0开发代号为Oak（橡树），于1996-01-23发行。 JDK 1.1于1997-02-19发行。引入的新特性包括：引入JDBC（Java Database Connectivity）；支持内部类；引入Java Bean；引入RMI（Remote Method Invocation）；引入反射（仅用于内省）。 JDK 1.2开发代号为Playground（操场），于1998-12-0">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://github.lushunde.com/2018/07/08/JDK各版本的特新/"/>





  <title>JDK各版本新特性介绍 | 十四心</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
	 <a href="https://github.com/lushunde321"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_darkblue_121621.png" alt="Fork me on GitHub"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">十四心</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">纸上得来终觉浅，绝知此事要躬行。    -小码</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            日程表
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

	
    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://github.lushunde.com/2018/07/08/JDK各版本的特新/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="鲁顺德">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://githubimg.lushunde.com/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十四心">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JDK各版本新特性介绍</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-08T00:48:20+08:00">
                2018-07-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-eye"></i> 本文阅读
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  13,907 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  57 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="JDK-1-0"><a href="#JDK-1-0" class="headerlink" title="JDK 1.0"></a>JDK 1.0</h1><p>开发代号为Oak（橡树），于1996-01-23发行。</p>
<h1 id="JDK-1-1"><a href="#JDK-1-1" class="headerlink" title="JDK 1.1"></a>JDK 1.1</h1><p>于1997-02-19发行。<br><strong>引入的新特性包括：</strong><br>引入JDBC（Java Database Connectivity）；<br>支持内部类；<br>引入Java Bean；<br>引入RMI（Remote Method Invocation）；<br>引入反射（仅用于内省）。</p>
<h1 id="JDK-1-2"><a href="#JDK-1-2" class="headerlink" title="JDK 1.2"></a>JDK 1.2</h1><p>开发代号为Playground（操场），于1998-12-08发行。<br><strong>引入的新特性包括：</strong><br>引入集合（Collection）框架；<br>对字符串常量做内存映射；<br>引入JIT（Just In Time）编译器；<br>引入对打包的Java文件进行数字签名；<br>引入控制授权访问系统资源的策略工具；<br>引入JFC（Java Foundation Classes），包括Swing 1.0、拖放和Java 2D类库；<br>引入Java 插件；<br>在JDBC中引入可滚动结果集、BLOB、CLOB、批量更新和用户自定义类型；<br>在Applet中添加声音支持。</p>
<h1 id="JDK-1-3"><a href="#JDK-1-3" class="headerlink" title="JDK 1.3"></a>JDK 1.3</h1><p>开发代号为Kestrel（红隼），于2000-05-08发行。<br><strong>引入的新特性包括：</strong><br>引入Java Sound API；<br>jar文件索引；<br>对Java的各个方面都做了大量优化和增强。</p>
<h1 id="JDK-1-4"><a href="#JDK-1-4" class="headerlink" title="JDK 1.4"></a>JDK 1.4</h1><p>开发代号为Merlin（隼），于2004-02-06发行（首次在JCP下发行）。<br><strong>引入的新特性包括:</strong><br>XML处理；<br>Java打印服务；<br>引入Logging API；<br>引入Java Web Start；<br>引入JDBC 3.0 API；<br>引入断言；<br>引入Preferences API；<br>引入链式异常处理；<br>支持IPv6；<br>支持正则表达式；<br>引入Image I/O slot machine API。</p>
<h1 id="JDK-5-0"><a href="#JDK-5-0" class="headerlink" title="JDK 5.0"></a>JDK 5.0</h1><p>开发代号为Tiger（老虎），于2004-09-30发行。<br><strong>引入的新特性包括:</strong><br>引入泛型；<br>增强循环，可以使用迭代方式；<br>自动装箱与自动拆箱；<br>类型安全的枚举；<br>可变参数；<br>静态引入；<br>元数据（注解）；<br>引入Instrumentation。</p>
<h1 id="JDK-6-0"><a href="#JDK-6-0" class="headerlink" title="JDK 6.0"></a>JDK 6.0</h1><p>开发代号为Mustang（野马），于2006-12-11发行。<br><strong>引入的新特性包括：</strong><br>支持脚本语言；<br>引入JDBC 4.0 API；<br>引入Java Compiler API；<br>可插拔注解；<br>增加对Native PKI(Public Key Infrastructure)、Java GSS(Generic Security Service)、Kerberos和LDAP(Lightweight Directory Access Protocol)的支持；<br>继承Web Services；<br>做了很多优化。</p>
<h1 id="JDK-7-0"><a href="#JDK-7-0" class="headerlink" title="JDK 7.0"></a>JDK 7.0</h1><p>开发代号是Dolphin（海豚），于2011-07-28发行。<br><strong>引入的新特性包括：</strong><br>switch语句块中允许以字符串作为分支条件；<br>在创建泛型对象时应用类型推断；<br>在一个语句块中捕获多种异常；<br>支持动态语言；<br>支持try-with-resources；<br>引入Java NIO.2开发包；<br>数值类型可以用2进制字符串表示，并且可以在字符串表示中添加下划线；<br>钻石型语法；<br>null值的自动处理。</p>
<h1 id="JDK-8-0"><a href="#JDK-8-0" class="headerlink" title="JDK 8.0"></a>JDK 8.0</h1><p>Java 8是于2014年3月14号发布。从Java 8开始开发代号已经弃用了，所以从Java 8之后已经没有官方的开发代号了。<br><strong>Java SE 8中的新特性</strong><br>Lambda表达式<br>Pipelines和Streams<br>Date和Time API<br>Default方法<br>Type注解<br>Nashhorn JavaScript引擎<br>并发计数器<br>Parallel操作<br>移除PermGen Error<br>TLS SNI</p>
<h1 id="JDK-9-0"><a href="#JDK-9-0" class="headerlink" title="JDK 9.0"></a>JDK 9.0</h1><p>Jigsaw 项目;模块化源码<br>简化进程API<br>轻量级 JSON API<br>钱和货币的API<br>改善锁争用机制<br>代码分段缓存<br>智能Java编译, 第二阶段<br>HTTP 2.0客户端<br>Kulla计划: Java的REPL实现</p>
<h1 id="JDK-10"><a href="#JDK-10" class="headerlink" title="JDK 10"></a>JDK 10</h1><h2 id="——————————————————————"><a href="#——————————————————————" class="headerlink" title="——————————————————————-"></a>——————————————————————-</h2><h2 id="JDK1-5新特性："><a href="#JDK1-5新特性：" class="headerlink" title="JDK1.5新特性："></a>JDK1.5新特性：</h2><h4 id="1-自动装箱与拆箱："><a href="#1-自动装箱与拆箱：" class="headerlink" title="1.自动装箱与拆箱："></a>1.自动装箱与拆箱：</h4><p>解释：<br>自动将基本数据类型转化为对应的封装类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">   Integer i = 3;</span><br><span class="line">System.out.println(i + 12);  //自动装箱和拆箱 完成Integer 和 int的相互转换</span><br><span class="line"></span><br><span class="line">Integer i1 = 100; //(-128--127范围时，为true);</span><br><span class="line">Integer i2 = 100; //(-128--127范围时，为true);</span><br><span class="line">System.out.println(i1 == i2); //true，原因是Integer采用的是享元模式，范围 （-128--127 ）</span><br><span class="line"></span><br><span class="line">Integer i3 = 130; //(-128--127范围时，为true);</span><br><span class="line">Integer i4 = 130; //(-128--127范围时，为true);</span><br><span class="line">System.out.println(i3 == i4); //false，原因是Integer超过范围则不是享元模式</span><br><span class="line"></span><br><span class="line">char c1 = &apos;a&apos;;</span><br><span class="line">char c2 = &apos;a&apos;;</span><br><span class="line">System.out.println(c1==c2);//true 原因是char也是享元模式</span><br><span class="line"></span><br><span class="line">String s1 = &quot;a&quot;;</span><br><span class="line">String s2 = &quot;a&quot;;</span><br><span class="line">System.out.println(s1==s2);//true 原因是String字符串不可变，&quot;a&quot;的引用地址直接赋值给s1和s2</span><br><span class="line"></span><br><span class="line">String s3 = new String(&quot;a&quot;);</span><br><span class="line">String s4 = new String(&quot;a&quot;);</span><br><span class="line">System.out.println(s3==s4);//false 原因是String字符串&quot;a&quot;不可变，但new两个对象存储&quot;a&quot;的地址，分别将这两个new的地址赋值给s3和s4</span><br></pre></td></tr></table></figure>
<h4 id="2-枚举-常用来设计单例模式"><a href="#2-枚举-常用来设计单例模式" class="headerlink" title="2.枚举(常用来设计单例模式)"></a>2.枚举(常用来设计单例模式)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">    private static void enumTest() &#123;</span><br><span class="line">	WeekDay weekDay1 = WeekDay.FRI;</span><br><span class="line">	System.out.println(weekDay1);</span><br><span class="line">	System.out.println(weekDay1.name());</span><br><span class="line">	System.out.println(WeekDay.valueOf(&quot;SUN&quot;).toString()); // 匹配输出</span><br><span class="line">	System.out.println(WeekDay.values().length); // 长度</span><br><span class="line"></span><br><span class="line">	TrafficLamp green = TrafficLamp.GREEN;</span><br><span class="line">	System.out.println(green);</span><br><span class="line">	System.out.println(green.nextLamp());</span><br><span class="line">	System.out.println(TrafficLamp.YELLOW.ordinal()); // 当前值得位置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public enum WeekDay &#123;</span><br><span class="line">	SUN(7), MON(), TUE(), WED(), THI(), FRI(5), SAT(6);</span><br><span class="line">	private WeekDay() &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private WeekDay(int i) &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public enum TrafficLamp &#123;</span><br><span class="line">	RED(30) &#123;</span><br><span class="line">		public TrafficLamp nextLamp() &#123;</span><br><span class="line">			return GREEN;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	GREEN(45) &#123;</span><br><span class="line">		public TrafficLamp nextLamp() &#123;</span><br><span class="line">			return YELLOW;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	YELLOW(5) &#123;</span><br><span class="line">		public TrafficLamp nextLamp() &#123;</span><br><span class="line">			return RED;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	public abstract TrafficLamp nextLamp();</span><br><span class="line"></span><br><span class="line">	private int time;</span><br><span class="line"></span><br><span class="line">	private TrafficLamp(int time) &#123;</span><br><span class="line">		this.time = time;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-静态导入"><a href="#3-静态导入" class="headerlink" title="3.静态导入"></a>3.静态导入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import static java.lang.Math.*;  //静态导入</span><br><span class="line">private static void test3() &#123;</span><br><span class="line">		int x = 1;</span><br><span class="line">		try &#123;</span><br><span class="line">		   x++;</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">		   System.out.println(&quot;template&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		 </span><br><span class="line">		System.out.println(x);</span><br><span class="line">		  </span><br><span class="line">		System.out.println(max(3, 6));  //不必在使用 Math.max(3,6)</span><br><span class="line">		System.out.println(abs(3 - 6));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-可变参数"><a href="#4-可变参数" class="headerlink" title="4.可变参数"></a>4.可变参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   //可变参数 调用</span><br><span class="line">	System.out.println(add(10));</span><br><span class="line">	System.out.println(add(10,15));</span><br><span class="line">	System.out.println(add(10,15,20,1));</span><br><span class="line"></span><br><span class="line">   //定义可变参数方法</span><br><span class="line">private static int add(int a ,int... args) &#123;</span><br><span class="line">	int sum = a;</span><br><span class="line">	for (int i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">		sum += args[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return sum;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-内省"><a href="#5-内省" class="headerlink" title="5.内省"></a>5.内省</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ReflectPoint pt1 = new ReflectPoint(3,5);</span><br><span class="line"></span><br><span class="line">BeanInfo beanInfo = Introspector.getBeanInfo(pt1.getClass());</span><br><span class="line">   PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors();</span><br><span class="line">   Object retVal = null;</span><br><span class="line">   for(PropertyDescriptor pd : pds)&#123;</span><br><span class="line">     Method methodGetX = pd.getReadMethod();</span><br><span class="line">     retVal = methodGetX.invoke(pt1);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="jdk1-6新特性："><a href="#jdk1-6新特性：" class="headerlink" title="jdk1.6新特性："></a>jdk1.6新特性：</h2><p>1.Web服务元数据</p>
<p>Java 里的Web服务元数据跟微软的方案基本没有语义上的区别,自从JDK5添加了元数据功能(Annotation)之后,SUN几乎重构了整个J2EE体 系, 由于变化很大,干脆将名字也重构为Java EE, Java EE(当前版本为5.0)将元数据纳入很多规范当中,这其中就包括Web Services的相关规范, 加入元数据之后的Web Services服务器端编程模型就跟上面看到的C#片断差不多了, 这显然比以前的JAX-RPC编程模型简单(当然, Axis的编程模型也很简单).这里要谈的Web服务元数据(JSR 181)只是Java Web 服务规范中的一个,它跟Common Annotations, JAXB2, StAX, SAAJ和JAX-WS等共同构成Java EE 5的Web Services技术堆栈.</p>
<p>package WebServices;</p>
<p>import java.io.File;<br>import java.io.IOException;<br>import javax.jws.Oneway;<br>import javax.jws.WebMethod;<br>import javax.jws.WebParam;<br>import javax.jws.WebResult;<br>import javax.jws.WebService;<br>import javax.xml.ws.Endpoint;</p>
<p>@WebService(targetNamespace=”<a href="http://blog.csdn.net/chinajash&quot;,serviceName=&quot;HelloService" target="_blank" rel="noopener">http://blog.csdn.net/chinajash&quot;,serviceName=&quot;HelloService</a>“)<br>public class WSProvider {<br>     @WebResult(name=”Greetings”)//自定义该方法返回值在WSDL中相关的描述<br>     @WebMethod<br>     public String sayHi(@WebParam(name=”MyName”) String name){<br>         return “Hi,”+name; //@WebParam是自定义参数name在WSDL中相关的描述<br>     }<br>     @Oneway //表明该服务方法是单向的,既没有返回值,也不应该声明检查异常<br>     @WebMethod(action=”printSystemTime”,operationName=”printSystemTime”)//自定义该方法在WSDL中相关的描述<br>     public void printTime(){<br>         System.out.println(System.currentTimeMillis());<br>     }<br>     public static void main(String[] args) {<br>         Thread wsPublisher = new Thread(new WSPublisher());<br>         wsPublisher.start();<br>     }<br>     private static class WSPublisher implements Runnable{<br>         public void run() {<br>             //发布WSProvider到<a href="http://localhost:8888/chinajash/WSProvider这个地址,之前必须调用wsgen命令" target="_blank" rel="noopener">http://localhost:8888/chinajash/WSProvider这个地址,之前必须调用wsgen命令</a><br>             //生成服务类WSProvider的支持类,命令如下:<br>             //wsgen -cp . WebServices.WSProvider<br>             Endpoint.publish(“<a href="http://localhost:8888/chinajash/WSProvider&quot;,new" target="_blank" rel="noopener">http://localhost:8888/chinajash/WSProvider&quot;,new</a> WSProvider());<br>         }<br>     }<br>}</p>
<p>如果想看到Web Services Engine生成的WSDL文件是否遵守上面的元数据, 我们没有必要将上面的WSProvider部署到支持JSR-181的应用服务器或Servlet形式的Web Services Engine,现在JDK6已经提供了一个很简单的机制可以用来测试和发布Web Services,下面讲讲如何在JDK6环境下发布Web Services和查看生成的WSDL<br>1.将<jdk_home>/bin加入path环境变量<br>2.在命令行下切换当前目录到WSProvider的class文件所在的目录,运行下面命令<br>wsgen -cp . WebServices.WSProvider<br>在这个例子中会生成以下3个类的源代码文件及class文件<br>SayHi<br>SayHiResponse<br>PrintTime<br>3.执行如下代码发布WSProvider到<a href="http://localhost:8888/chinajash/WSProvider,在这里可以执行WSProvider类的main方法就可以" target="_blank" rel="noopener">http://localhost:8888/chinajash/WSProvider,在这里可以执行WSProvider类的main方法就可以</a><br>Endpoint.publish(“<a href="http://localhost:8888/chinajash/WSProvider&quot;,new" target="_blank" rel="noopener">http://localhost:8888/chinajash/WSProvider&quot;,new</a> WSProvider());<br>4.在浏览器输入<a href="http://localhost:8888/chinajash/WSProvider?wsdl就可以看到生成的WSDL文件，为了节省篇幅,这里就不把生成的WSDL文件贴上了，大家可以自己动手试试" target="_blank" rel="noopener">http://localhost:8888/chinajash/WSProvider?wsdl就可以看到生成的WSDL文件，为了节省篇幅,这里就不把生成的WSDL文件贴上了，大家可以自己动手试试</a>.<br>2.脚本语言支持</jdk_home></p>
<p>JDK6增加了对脚本语言的支持(JSR 223)， 原理上是将脚本语言编译成bytecode，这样脚本语言也能享用Java平台的诸多优势，包括可移植性，安全等，另外，由于现在是编译成 bytecode后再执行，所以比原来边解释边执行效率要高很多。加入对脚本语言的支持后，对Java语言也提供了以下好处。<br>1、许多脚本语言都有动态特性，比如，你不需要用一个变量之前先声明它，你可以用一个变量存放完全不同类型的对象，你不需要做强制类型转换，因为转换都是自动的。现在Java语言也可以通过对脚本语言的支持间接获得这种灵活性。<br>2、 可以用脚本语言快速开发产品原型，因为现在可以Edit-Run，而无需Edit-Compile-Run，当然，因为Java有非常好的IDE支持，我 们完全可以在IDE里面编辑源文件，然后点击运行(隐含编译)，以此达到快速开发原型的目的，所以这点好处基本上可以忽略。<br>3、通过引入脚本语言可以轻松实现Java应用程序的扩展和自定义，我们可以把原来分布在在Java应用程序中的配置逻辑，数学表达式和业务规则提取出来，转用JavaScript来处理。</p>
<p>Sun的JDK6实现包含了一个基于Mozilla Rhino的 脚本语言引擎，支持JavaScript，这并不是说明JDK6只支持JavaScript，任何第三方都可以自己实现一个JSR-223兼容的脚本引擎 使得JDK6支持别的脚本语言，比如，你想让JDK6支持Ruby，那你可以自己按照JSR 223 的规范实现一个Ruby的脚本引擎类，具体一点，你需要实现javax.script.ScriptEngine(简单起见，可以继承 javax.script.AbstractScriptEngine)和javax.script.ScriptEngineFactory两个接口。 当然，在你实现自己的脚本语言引擎之前，先到scripting.dev.java.net project 这里看看是不是有人已经帮你做了工作，这样你就可以直接拿来用就行。</p>
<p>Scripting API</p>
<hr>
<p>Scripting API是用于在Java里面编写脚本语言程序的API， 在Javax.script中可以找到Scripting API，我们就是用这个API来编写JavaScript程序，这个包里面有一个ScriptEngineManager类，它是使用Scripting API的入口，ScriptEngineManager可以通过jar服务发现(service discovery)机制寻找合适的脚本引擎类(ScriptEngine)，使用Scripting API的最简单方式只需下面三步<br>1、创建一个ScriptEngineManager对象<br>2、通过ScriptEngineManager获得ScriptEngine对象<br>3、用ScriptEngine的eval方法执行脚本</p>
<p>下面是一个Hello World程序</p>
<p>public class HelloScript {public static void main(String[] args) throws Exception {         ScriptEngineManager factory = new ScriptEngineManager();//step 1         ScriptEngine engine = factory.getEngineByName(“JavaScript”);//Step 2             engine.eval_r(“print(‘Hello, Scripting’)”);//Step 3     }     }运行上面程序，控制台会输出Hello, Scripting上面这个简单的Scripting程序演示了如何在Java里面运行脚本语言，除此之外，我们还可以利用Scripting API实现以下功能1、暴露Java对象为脚本语言的全局变量2、在Java中调用脚本语言的方法3、脚本语言可以实现Java的接口4、脚本语言可以像Java一样使用JDK平台下的类下面的类演示了以上4种功能package Scripting;import java.io.File;import javax.script.Invocable;import javax.script.ScriptEngine;import javax.script.ScriptEngineManager;import javax.script.ScriptException;public class ScriptingAPITester {     public static void main(String[] args) throws Exception {         ScriptEngineManager manager = new ScriptEngineManager();         ScriptEngine engine = manager.getEngineByName(“JavaScript”);         testScriptVariables(engine);//演示如何暴露Java对象为脚本语言的全局变量          testInvokeScriptMethod(engine);//演示如何在Java中调用脚本语言的方法          testScriptInterface(engine);//演示脚本语言如何实现Java的接口          testUsingJDKClasses(engine);//演示脚本语言如何使用JDK平台下的类     }         public static void testScriptVariables(ScriptEngine engine) throws ScriptException{         File file = new File(“test.txt”);         engine.put(“f”, file);         engine.eval_r(“println(‘Total Space:’+f.getTotalSpace())”);             }         public static void testInvokeScriptMethod(ScriptEngine engine) throws Exception{         String script = “function hello(name) { return ‘Hello,’ + name;}”;         engine.eval_r(script);         Invocable inv = (Invocable) engine;         String res = (String)inv.invokeFunction(“hello”, “Scripting” );         System.out.println(“res:”+res);     }         public static void testScriptInterface(ScriptEngine engine) throws ScriptException{         String script = “var obj = new Object(); obj.run = function() { println(‘run method called’); }”;         engine.eval_r(script);         Object obj = engine.get(“obj”);         Invocable inv = (Invocable) engine;         Runnable r = inv.getInterface(obj,Runnable.class);         Thread th = new Thread(r);         th.start();     }         public static void testUsingJDKClasses(ScriptEngine engine) throws Exception{         //Packages是脚本语言里的一个全局变量,专用于访问JDK的package         String js = “function doSwing(t){var f=new Packages.javax.swing.JFrame(t);f.setSize(400,300);f.setVisible(true);}”;         engine.eval_r(js);         Invocable inv = (Invocable) engine;         inv.invokeFunction(“doSwing”, “Scripting Swing” );     }}Scripting Tool</p>
<hr>
<p>SUN 提供的JDK6中有一个命令行工具??jrunscript，你可以在<jdk6_home>/bin下面找到这个工 具，jrunscript是一个脚本语言的解释程序，它独立于脚本语言，但默认是用JavaScript，我们可以用jrunscript来测试自己写的 脚本语言是否正确，下面是一个在命令行运行jrunscript的简单例子<br>jrunscript<br>js&gt;println(“Hello,JrunScript”);<br>Hello,JrunScript<br>js&gt;9*8<br>72.0<br>js&gt;<br>3.JTable的排序和过滤</jdk6_home></p>
<p>原来的JTable基本上是只能显示数据，在JDK6新增了对JTable的排序和过滤功能，下面代码演示了这两个功能</p>
<p>public class JTableTester {<br>     static String data[][] = {<br>         {“China”,”Beijing”,”Chinese”},<br>         {“America”,”Washington”,”English”},<br>         {“Korea”,”Seoul”,”Korean”},<br>         {“Japan”,”Tokyo”,”Japanese”},<br>         {“France”,”Paris”,”French”},<br>         {“England”,”London”,”English”},<br>         {“Germany”,”Berlin”,”German”},<br>     };<br>     static String titles[] = {“Country”,”Capital”,”Language”};<br>     public static void main(String[] args) {<br>         DefaultTableModel m = new DefaultTableModel(data,titles);<br>         JTable t = new JTable(m);<br>         final TableRowSorter sorter = new TableRowSorter(m);<br>         t.setRowSorter(sorter); //为JTable设置排序器</p>
<pre><code>    JScrollPane sPane = new JScrollPane();
    sPane.setViewportView(t);

    JPanel p = new JPanel();
    p.setLayout(new BoxLayout(p,BoxLayout.X_AXIS));
    JLabel l = new JLabel(&quot;Criteria:&quot;);
    final JTextField tf = new JTextField();
    JButton b = new JButton(&quot;Do Filter&quot;);
    p.add(l);
    p.add(tf);
    p.add(b);
    b.addActionListener(new ActionListener() {
        public void actionPerformed(ActionEvent e) {
            if(tf.getText().length()==0){
                sorter.setRowFilter(null);
            }else{
                sorter.setRowFilter(RowFilter.regexFilter(tf.getText()));//为JTable设置基于正则表达式的过滤条件
            }
        }
    });

    JFrame f = new JFrame(&quot;JTable Sorting and Filtering&quot;);
    f.getContentPane().add(sPane,BorderLayout.CENTER);        
    f.getContentPane().add(p,BorderLayout.SOUTH);
    f.setSize(400,300);
    f.setVisible(true);
}
</code></pre><p>}<br>运行上面程序，单击JTable的某一个title，这个title对应的列就会按照升序/降序重新排列；在下面的Criteria文本框中输入”ese”，点击”Do Filter”按钮，JTable将只显示带有”ese”字符串的行，也就是China和Japan两行，如果文本框里面什么都没有，点击”Do Filter”按钮，这时JTable会显示所有的行。<br>4.更简单,更强大的JAX-WS</p>
<p>JAX-WS2.0的来历</p>
<hr>
<p>JAX-WS(JSR-224) 是Java Architecture for XML Web Services的缩写,简单说就是一种用Java和XML开发Web Services应用程序的框架, 目前版本是2.0, 它是JAX-RPC 1.1的后续版本, J2EE 1.4带的就是JAX-RPC1.1, 而Java EE 5里面包括了JAX-WS 2.0,但为了向后兼容,仍然支持JAX-RPC. 现在,SUN又把JAX-WS直接放到了Java SE 6里面,由于JAX-WS会用到Common Annotation(JSR 250),Java Web Services Metadata(JSR 181), JAXB2(JSR 222), StAX(JSR 173), 所以SUN也必须把后几个原属于Java EE范畴的Components下放到Java SE, 现在我们可以清楚地理解了为什么Sun要把这些看似跟Java SE没有关系的Components放进来,终极目的就是要在Java SE里面支持Web Services.</p>
<p>JAX-WS2.0的架构</p>
<hr>
<p>JAX-WS不是一个孤立的框架,它依赖于众多其他的规范,本质上它由以下几部分组成<br>1.用来开发Web Services的Java API<br>2.用来处理Marshal/Unmarshal的XML Binding机制,JAX-WS2.0用JAXB2来处理Java Object与XML之间的映射,Marshalling就是把Java Object映射到XML,Unmarshalling则是把XML映射到Java Object.之所以要做Java Object与XML的映射,是因为最终作为方法参数和返回值的Java Object要通过网络传输协议(一般是SOAP)传送,这就要求必须对Java Object做类似序列化和反序列化的工作,在SOAP中就是要用XML来表示Java object的内部状态<br>3.众多元数据(Annotations)会被JAX-WS用来描述Web Services的相关类,包括Common Annotations, Web Services Metadata, JAXB2的元数据和JAX-WS2.0规范自己的元数据.<br>4.Annotation Processing Tool(APT) 是JAX-WS重要的组成部分,由于JAX-WS2.0规范用到很多元数据,所以需要APT来处理众多的Annotations. 在<jdk_home>/bin下有两个命令wsgen和wsimport,就是用到APT和Compiler API来处理碰到的Annotations,wsgen可以为Web Services Provider产生并编译必要的帮助类和相关支持文件,wsimport以WSDL作为输入为Web Service Consumer产生并编译必要的帮助类和相关支持文件.<br>5.JAX-WS还包括JAX-WS Runtime与应用服务器和工具之间的契约关系</jdk_home></p>
<p>JAX-WS2.0的编程模型</p>
<hr>
<p>现在用JAX-WS2.0来编写Web Services非常简单,不像JAX-RPC,JAX-WS可以把任意POJO暴露为Web Services,服务类不需要实现接口,服务方法也没有必要抛出RMI异常.下面介绍在JDK6环境下用JAX-WS2.0开发和测试Web Services的步骤<br>1.编写服务类,并用Web Services Metadata(JSR-181)标注这个服务类,我用我的另一篇BlogJDK6的新特性之十:Web服务元数据中的WSProvider类作为服务类的例子,在此我重复贴一下WSProvider类的源代码:</p>
<p>@WebService(targetNamespace=”<a href="http://blog.csdn.net/chinajash&quot;,serviceName=&quot;HelloService" target="_blank" rel="noopener">http://blog.csdn.net/chinajash&quot;,serviceName=&quot;HelloService</a>“)<br>public class WSProvider {<br>     @WebResult(name=”Greetings”)//自定义该方法返回值在WSDL中相关的描述<br>     @WebMethod<br>     public String sayHi(@WebParam(name=”MyName”) String name){<br>         return “Hi,”+name; //@WebParam是自定义参数name在WSDL中相关的描述<br>     }<br>     @Oneway //表明该服务方法是单向的,既没有返回值,也不应该声明检查异常<br>     @WebMethod(action=”printSystemTime”,operationName=”printSystemTime”)//自定义该方法在WSDL中相关的描述<br>     public void printTime(){<br>         System.out.println(System.currentTimeMillis());<br>     }<br>     public static void main(String[] args) {<br>         Thread wsPublisher = new Thread(new WSPublisher());<br>         wsPublisher.start();<br>     }<br>     private static class WSPublisher implements Runnable{<br>         public void run() {<br>             //发布WSProvider到<a href="http://localhost:8888/chinajash/WSProvider这个地址,之前必须调用wsgen命令" target="_blank" rel="noopener">http://localhost:8888/chinajash/WSProvider这个地址,之前必须调用wsgen命令</a><br>             //生成服务类WSProvider的支持类,命令如下:<br>             //wsgen -cp . WebServices.WSProvider<br>             Endpoint.publish(“<a href="http://localhost:8888/chinajash/WSProvider&quot;,new" target="_blank" rel="noopener">http://localhost:8888/chinajash/WSProvider&quot;,new</a> WSProvider());<br>         }<br>     }<br>}<br>2.用wsgen生成上面服务类的必要的帮助类,然后调用用EndPoint类的静态方法publish发布服务类(步骤请参考我的另一篇Blog JDK6的新特性之十:Web服务元数据),我在这里是将服务类发布到<a href="http://localhost:8888/chinajash/WSProvider" target="_blank" rel="noopener">http://localhost:8888/chinajash/WSProvider</a><br>3.用wsimport为服务消费者(也就是服务的客户端)生成必要的帮助类,命令如下:<br>wsimport <a href="http://localhost:8888/chinajash/WSProvider?wsdl" target="_blank" rel="noopener">http://localhost:8888/chinajash/WSProvider?wsdl</a><br>这会在&lt;当前目录&gt;\net\csdn\blog\chinajash下生成客户端的帮助类,在这个例子中会生成7个类<br>HelloService.class<br>ObjectFactory.class<br>package-info.class<br>PrintSystemTime.class<br>SayHi.class<br>SayHiResponse.class<br>WSProvider.class<br>4.在客户端用下面代码即可调用步骤1定义的Web Service<br>HelloService hs = new HelloService();<br>WSProvider ws = hs.getWSProviderPort();<br>System.out.println(ws.sayHi(“chinajash”));<br>ws.printSystemTime();<br>调用上述代码后客户端控制台输出<br>hi,chinajash<br>服务端控制台输出服务器当前系统时间<br>5.轻量级Http Server</p>
<p>JDK6的新特性之五:轻量级Http Server</p>
<p>JDK6提供了一个简单的Http Server API,据此我们可以构建自己的嵌入式Http Server,它支持Http和Https协议,提供了HTTP1.1的部分实现，没有被实现的那部分可以通过扩展已有的Http Server API 来实现,程序员必须自己实现HttpHandler接口,HttpServer会调用HttpHandler实现类的回调方法来处理客户端请求,在这里, 我们把一个Http请求和它的响应称为一个交换,包装成HttpExchange类,HttpServer负责将HttpExchange传给 HttpHandler实现类的回调方法.下面代码演示了怎样创建自己的Http Server</p>
<p>public class HTTPServerAPITester {<br>     public static void main(String[] args) {<br>         try {<br>             HttpServer hs = HttpServer.create(new InetSocketAddress(8888),0);//设置HttpServer的端口为8888<br>             hs.createContext(“/chinajash”, new MyHandler());//用MyHandler类内处理到/chinajash的请求<br>             hs.setExecutor(null); // creates a default executor<br>             hs.start();<br>         } catch (IOException e) {<br>             e.printStackTrace();<br>         }<br>     }<br>}</p>
<p>class MyHandler implements HttpHandler {<br>    public void handle(HttpExchange t) throws IOException {<br>        InputStream is = t.getRequestBody();<br>        String response = “</p><h3>Happy New Year 2007!–Chinajash</h3>“;<br>        t.sendResponseHeaders(200, response.length());<br>        OutputStream os = t.getResponseBody();<br>        os.write(response.getBytes());<br>        os.close();<br>    }<br>}<p></p>
<p>运行程序后,在浏览器内输入<a href="http://localhost:8888/xx,浏览器输出" target="_blank" rel="noopener">http://localhost:8888/xx,浏览器输出</a><br>6.嵌入式数据库 Derby</p>
<p>Derby是IBM送给开源社区的又一个礼物，是一个pure java的数据库，现在已经被列入到java1.6中。<br>不知道对于大数据量的性能如何，但传说中启动derby只会给JVM添加2M的内存，对那些小数据库应用，比如像用access那种应该是挺有诱惑力的。<br>另外，麻雀虽小，五脏俱全，功能要比access多得多咯，包括事务处理，并发，触发器都有，管理又简单，因此自己用来做点工具正好合适。<br>废话少说，介绍一下我折腾了半天的经验吧。<br>我的Derby配置过程：<br>1，下载db-derby-10.1.3.1-bin.tar.gz,derby_core_plugin_10.1.3.zip和derby_ui_plugin_1.1.0.zip，把两个插件安装到eclipse上<br>2，打开ecllipse,新建一个project<br>3，右键这个project，选择Apache Derby，再选择add apache derby native，发现只是给我的project添加了几个derby的jar，还不是在我看着顺眼的lib目录里，索性干掉，换上db-derby- 10.1.3.1-bin.tar.gz解压出来以后lib目录下的jar文件，在Build Path里设置一下；<br>4，右键Project，在apache derby里选择start apache derby network server，控制台可以看到derby启动后打出的“服务器准备在端口 1527 上接受连接。”<br>5，右键Project，在apache derby里选择ij(Interactive SQL)，启动SQL控制台；<br>6，输入connect jdbc:derby:testdb;create=true; 注意要有单引号，可以在工程跟目录下创建testdb数据库，可以看到一个新建的目录testdb，那里的文件就是数据库咯；<br>7，用标准的SQL语句来建一个数据库试试：<br>create table test (a varchar(4) not null, b char(2) primary key);<br>居然可以用，太神奇了，呵呵<br>8，再插入一条语句试试呢，insert into test(a,b) values(a,11);，嗯，不错，可以用select 查出来的哦。<br>9，再插一下：insert into test(a,b) values(a,11);，哦哦，报错了，“错误 23505：语句异常终止，因为它导致“TEST”上所定义的“SQL060710092132480”标识的唯一或主键约束或唯一索引中出现重复键值。” 呵呵。<br>10，好了，现在可以像你控制的其他数据库一样来控制Derby了。</p>
<p>如果上述方法不行，或者你习惯了在eclipse之外使用和管理数据库，那么可以很方便的把Derby“装”在系统里。下面我说一下步骤：<br>1，把db-derby-10.1.3.1-bin.tar.gz解压到c:\derby,使lib和framework两个目录在c:\derby下边即可<br>2，设置环境变量</p>
<p>设置一个c:\derby\framework\embeded\bin或c:\derby\framework\NetworkServe\bin到Path中，这样我们就可以直接执行上边介绍的connect这样的命令而不用每次钻到那个目录下去执行了<br>设置c:\derby\lib\derby.jar;c:\derby\lib\derbytoos.jar到CLASSPATH中，以便让这些java编成的命令能够正确执行；<br>3，打开cmd<br>4，敲入startNetworkServer，可以看到像在eclisp中提示的那样启动了server<br>5，再打开一个cmd,敲入sysinfo,可以看到derby的环境信息了，注意在java user dir这一项，也许是java用户目录上和上边看到的会有所不同哦，这样在connect jdbc:derby:testdb;create=true;的建的数据库目录就不一样咯。<br>6，敲入ij，好了，进入到上边的交互界面，可以建一个数据库看看了。<br>7，最后在另外一个cmd中敲入stopNetworkServer就可以关闭数据库了。</p>
<p>如果你两种方法都试过了，那么需要注意的，还是上边步骤5的问题，这个问题是你可能随时会启动一个数据库或新建一个数据库，但如果你刚刚使用derby，你可能还没有察觉。<br>derby实际上有两种启动方式，一种是嵌入式的，一种是网络服务器的启动。<br>1，我们在eclipse中右键start apache derby network server那个，就是网络服务器的启动方式，在这种方式下可以用另外一台计算机在ij中以：<br>connect jdbc:derby://192.168.0.28:1527/testdb<br>的方式进行链接。<br>2，第二种启动方式是在ij里边就直接<br>connect jdbc:derby:testdb<br>这实际是在连当前配置环境下java user dir下那个目录的数据库。</p>
<p>看到这里可能有点糊涂了，这么就会出问题了那？<br>实际上derby的访问更像是一种使用derby driver对本地文件系统的访问，不管启动不启动网络服务器，都可以用driver访问本地的数据库。这样，在ij里边像第二种方式那样建立连接是完全可以的。启动了网络服务器，只不过是能够让其他主机访问罢了。</p>
<p>另外一个问题是，在eclipse中和在系统中连接服务器，在connect的时候这个当前配置环境是不一样的，eclipse默认工程所在路径是数据库的所在路径，而在系统中“装”derby则会认为 c:\document and settings下边那个用户目录是数据库的所在路径。<br>jdk1.7新特性：</p>
<p>1，switch中可以使用字串了<br>String s = “test”;<br>switch (s) {<br>case “test” :<br>     System.out.println(“test”);<br>case “test1” :<br>    System.out.println(“test1”);<br>    break ;<br>default :<br>    System.out.println(“break”);<br>    break ;<br>}</p>
<p>2.运用List<string> tempList = new ArrayList&lt;&gt;(); 即泛型实例化类型自动推断<br>3.语法上支持集合，而不一定是数组</string></p>
<p>final List<integer> piDigits = [ 1,2,3,4,5,8 ];<br>4.新增一些取环境信息的工具方法</integer></p>
<p>File System.getJavaIoTempDir() // IO临时文件夹</p>
<p>File System.getJavaHomeDir() // JRE的安装目录</p>
<p>File System.getUserHomeDir() // 当前用户目录</p>
<p>File System.getUserDir() // 启动java进程时所在的目录5</p>
<p>5.Boolean类型反转，空指针安全,参与位运算</p>
<p>Boolean Booleans.negate(Boolean booleanObj)</p>
<p>True =&gt; False , False =&gt; True, Null =&gt; Null</p>
<p>boolean Booleans.and(boolean[] array)</p>
<p>boolean Booleans.or(boolean[] array)</p>
<p>boolean Booleans.xor(boolean[] array)</p>
<p>boolean Booleans.and(Boolean[] array)</p>
<p>boolean Booleans.or(Boolean[] array)</p>
<p>boolean Booleans.xor(Boolean[] array)</p>
<p>6.两个char间的equals<br>boolean Character.equalsIgnoreCase(char ch1, char ch2)<br>7.安全的加减乘除<br>int Math.safeToInt(long value)</p>
<p>int Math.safeNegate(int value)</p>
<p>long Math.safeSubtract(long value1, int value2)</p>
<p>long Math.safeSubtract(long value1, long value2)</p>
<p>int Math.safeMultiply(int value1, int value2)</p>
<p>long Math.safeMultiply(long value1, int value2)</p>
<p>long Math.safeMultiply(long value1, long value2)</p>
<p>long Math.safeNegate(long value)</p>
<p>int Math.safeAdd(int value1, int value2)</p>
<p>long Math.safeAdd(long value1, int value2)</p>
<p>long Math.safeAdd(long value1, long value2)</p>
<p>int Math.safeSubtract(int value1, int value2)</p>
<p>8.map集合支持并发请求，且可以写成 Map map = {name:”xxx”,age:18};</p>
<hr>
<p>欢迎阅读我编写的Java 8介绍。本教程将带领你一步一步地认识这门语言的新特性。通过简单明了的代码示例，你将会学习到如何使用默认接口方法，Lambda表达式，方法引用和重复注解。看完这篇教程后，你还将对最新推出的API有一定的了解，例如：流控制，函数式接口，map扩展和新的时间日期API等等。</p>
<p>目 录 [ - ]<br>允许在接口中有默认方法实现<br>Lambda表达式<br>函数式接口<br>方法和构造函数引用<br>Lambda的范围<br>内置函数式接口<br>Streams<br>Parallel Streams<br>Map<br>时间日期API<br>Annotations<br>总结<br>允许在接口中有默认方法实现 Top<br>Java 8 允许我们使用default关键字，为接口声明添加非抽象的方法实现。这个特性又被称为扩展方法。下面是我们的第一个例子： </p>
<p>Java代码<br>interface Formula {<br>    double calculate(int a);  </p>
<pre><code>default double sqrt(int a) {  
    return Math.sqrt(a);  
}  
</code></pre><p>}  </p>
<p>在接口Formula中，除了抽象方法caculate以外，还定义了一个默认方法sqrt。Formula的实现类只需要实现抽象方法caculate就可以了。默认方法sqrt可以直接使用。 </p>
<p>Java代码<br>Formula formula = new Formula() {<br>    @Override<br>    public double calculate(int a) {<br>        return sqrt(a * 100);<br>    }<br>};  </p>
<p>formula.calculate(100);     // 100.0<br>formula.sqrt(16);           // 4.0  </p>
<p>formula对象以匿名对象的形式实现了Formula接口。代码很啰嗦：用了6行代码才实现了一个简单的计算功能：a*100开平方根。我们在下一节会看到，Java 8 还有一种更加优美的方法，能够实现包含单个函数的对象。 </p>
<p>Lambda表达式 Top<br>让我们从最简单的例子开始，来学习如何对一个string列表进行排序。我们首先使用Java 8之前的方法来实现： </p>
<p>Java代码<br>List<string> names = Arrays.asList(“peter”, “anna”, “mike”, “xenia”);  </string></p>
<p>Collections.sort(names, new Comparator<string>() {<br>    @Override<br>    public int compare(String a, String b) {<br>        return b.compareTo(a);<br>    }<br>});  </string></p>
<p>静态工具方法Collections.sort接受一个list，和一个Comparator接口作为输入参数，Comparator的实现类可 以对输入的list中的元素进行比较。通常情况下，你可以直接用创建匿名Comparator对象，并把它作为参数传递给sort方法。 </p>
<p>除了创建匿名对象以外，Java 8 还提供了一种更简洁的方式，Lambda表达式。 </p>
<p>Java代码<br>Collections.sort(names, (String a, String b) -&gt; {<br>    return b.compareTo(a);<br>});  </p>
<p>你可以看到，这段代码就比之前的更加简短和易读。但是，它还可以更加简短： </p>
<p>Java代码<br>Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));  </p>
<p>只要一行代码，包含了方法体。你甚至可以连大括号对{}和return关键字都省略不要。不过这还不是最短的写法： </p>
<p>Java代码<br>Collections.sort(names, (a, b) -&gt; b.compareTo(a));  </p>
<p>Java编译器能够自动识别参数的类型，所以你就可以省略掉类型不写。让我们再深入地研究一下lambda表达式的威力吧。 </p>
<p>函数式接口 Top<br>Lambda表达式如何匹配Java的类型系统？每一个lambda都能够通过一个特定的接口，与一个给定的类型进行匹配。一个所谓的函数式接口必须要有 且仅有一个抽象方法声明。每个与之对应的lambda表达式必须要与抽象方法的声明相匹配。由于默认方法不是抽象的，因此你可以在你的函数式接口里任意添 加默认方法。 </p>
<p>任意只包含一个抽象方法的接口，我们都可以用来做成lambda表达式。为了让你定义的接口满足要求，你应当在接口前加上@FunctionalInterface 标注。编译器会注意到这个标注，如果你的接口中定义了第二个抽象方法的话，编译器会抛出异常。 </p>
<p>举例： </p>
<p>Java代码<br>@FunctionalInterface<br>interface Converter<f, t=""> {<br>    T convert(F from);<br>}  </f,></p>
<p>Converter<string, integer=""> converter = (from) -&gt; Integer.valueOf(from);<br>Integer converted = converter.convert(“123”);<br>System.out.println(converted);    // 123  </string,></p>
<p>注意，如果你不写@FunctionalInterface 标注，程序也是正确的。 </p>
<p>方法和构造函数引用 Top<br>上面的代码实例可以通过静态方法引用，使之更加简洁： </p>
<p>Java代码<br>Converter<string, integer=""> converter = Integer::valueOf;<br>Integer converted = converter.convert(“123”);<br>System.out.println(converted);   // 123  </string,></p>
<p>Java 8 允许你通过::关键字获取方法或者构造函数的的引用。上面的例子就演示了如何引用一个静态方法。而且，我们还可以对一个对象的方法进行引用： </p>
<p>Java代码<br>class Something {<br>    String startsWith(String s) {<br>        return String.valueOf(s.charAt(0));<br>    }<br>}  </p>
<p>Something something = new Something();<br>Converter<string, string=""> converter = something::startsWith;<br>String converted = converter.convert(“Java”);<br>System.out.println(converted);    // “J”  </string,></p>
<p>让我们看看如何使用::关键字引用构造函数。首先我们定义一个示例bean，包含不同的构造方法： </p>
<p>Java代码<br>class Person {<br>    String firstName;<br>    String lastName;  </p>
<pre><code>Person() {}  

Person(String firstName, String lastName) {  
    this.firstName = firstName;  
    this.lastName = lastName;  
}  
</code></pre><p>}  </p>
<p>接下来，我们定义一个person工厂接口，用来创建新的person对象： </p>
<p>Java代码<br>interface PersonFactory</p><p extends="" person=""> {<br>    P create(String firstName, String lastName);<br>}  </p>
<p>然后我们通过构造函数引用来把所有东西拼到一起，而不是像以前一样，通过手动实现一个工厂来这么做。 </p>
<p>Java代码<br>PersonFactory<person> personFactory = Person::new;<br>Person person = personFactory.create(“Peter”, “Parker”);  </person></p>
<p>我们通过Person::new来创建一个Person类构造函数的引用。Java编译器会自动地选择合适的构造函数来匹配PersonFactory.create函数的签名，并选择正确的构造函数形式。 </p>
<p>Lambda的范围 Top<br>对于lambdab表达式外部的变量，其访问权限的粒度与匿名对象的方式非常类似。你能够访问局部对应的外部区域的局部final变量，以及成员变量和静态变量。 </p>
<p>访问局部变量 </p>
<p>我们可以访问lambda表达式外部的final局部变量： </p>
<p>Java代码<br>final int num = 1;<br>Converter<integer, string=""> stringConverter =<br>        (from) -&gt; String.valueOf(from + num);  </integer,></p>
<p>stringConverter.convert(2);     // 3  </p>
<p>但是与匿名对象不同的是，变量num并不需要一定是final。下面的代码依然是合法的： </p>
<p>Java代码<br>int num = 1;<br>Converter<integer, string=""> stringConverter =<br>        (from) -&gt; String.valueOf(from + num);  </integer,></p>
<p>stringConverter.convert(2);     // 3  </p>
<p>然而，num在编译的时候被隐式地当做final变量来处理。下面的代码就不合法： </p>
<p>Java代码<br>int num = 1;<br>Converter<integer, string=""> stringConverter =<br>        (from) -&gt; String.valueOf(from + num);<br>num = 3;  </integer,></p>
<p>在lambda表达式内部企图改变num的值也是不允许的。 </p>
<p>访问成员变量和静态变量 </p>
<p>与局部变量不同，我们在lambda表达式的内部能获取到对成员变量或静态变量的读写权。这种访问行为在匿名对象里是非常典型的。 </p>
<p>Java代码<br>class Lambda4 {<br>    static int outerStaticNum;<br>    int outerNum;  </p>
<pre><code>void testScopes() {  
    Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; {  
        outerNum = 23;  
        return String.valueOf(from);  
    };  

    Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; {  
        outerStaticNum = 72;  
        return String.valueOf(from);  
    };  
}  
</code></pre><p>}  </p>
<p>访问默认接口方法 </p>
<p>还记得第一节里面formula的那个例子么？ 接口Formula定义了一个默认的方法sqrt，该方法能够访问formula所有的对象实例，包括匿名对象。这个对lambda表达式来讲则无效。 </p>
<p>默认方法无法在lambda表达式内部被访问。因此下面的代码是无法通过编译的： </p>
<p>Java代码<br>Formula formula = (a) -&gt; sqrt( a * 100);  </p>
<p>内置函数式接口 Top<br>JDK 1.8 API中包含了很多内置的函数式接口。有些是在以前版本的Java中大家耳熟能详的，例如Comparator接口，或者Runnable接口。对这些现 成的接口进行实现，可以通过@FunctionalInterface 标注来启用Lambda功能支持。 </p>
<p>此外，Java 8 API 还提供了很多新的函数式接口，来降低程序员的工作负担。有些新的接口已经在Google Guava库中很有名了。如果你对这些库很熟的话，你甚至闭上眼睛都能够想到，这些接口在类库的实现过程中起了多么大的作用。 </p>
<p>Predicates </p>
<p>Predicate是一个布尔类型的函数，该函数只有一个输入参数。Predicate接口包含了多种默认方法，用于处理复杂的逻辑动词（and, or，negate）： </p>
<p>Java代码<br>Predicate<string> predicate = (s) -&gt; s.length() &gt; 0;  </string></p>
<p>predicate.test(“foo”);              // true<br>predicate.negate().test(“foo”);     // false  </p>
<p>Predicate<boolean> nonNull = Objects::nonNull;<br>Predicate<boolean> isNull = Objects::isNull;  </boolean></boolean></p>
<p>Predicate<string> isEmpty = String::isEmpty;<br>Predicate<string> isNotEmpty = isEmpty.negate();  </string></string></p>
<p>Functions </p>
<p>Function接口接收一个参数，并返回单一的结果。默认方法可以将多个函数串在一起（compse, andThen）： </p>
<p>Java代码<br>Function<string, integer=""> toInteger = Integer::valueOf;<br>Function<string, string=""> backToString = toInteger.andThen(String::valueOf);  </string,></string,></p>
<p>backToString.apply(“123”);     // “123”  </p>
<p>Suppliers </p>
<p>Supplier接口产生一个给定类型的结果。与Function不同的是，Supplier没有输入参数。 </p>
<p>Java代码<br>Supplier<person> personSupplier = Person::new;<br>personSupplier.get();   // new Person  </person></p>
<p>Consumers </p>
<p>Consumer代表了在一个输入参数上需要进行的操作。 </p>
<p>Java代码<br>Consumer<person> greeter = (p) -&gt; System.out.println(“Hello, “ + p.firstName);<br>greeter.accept(new Person(“Luke”, “Skywalker”));  </person></p>
<p>Comparators </p>
<p>Comparator接口在早期的Java版本中非常著名。Java 8 为这个接口添加了不同的默认方法。 </p>
<p>Java代码<br>Comparator<person> comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);  </person></p>
<p>Person p1 = new Person(“John”, “Doe”);<br>Person p2 = new Person(“Alice”, “Wonderland”);  </p>
<p>comparator.compare(p1, p2);             // &gt; 0<br>comparator.reversed().compare(p1, p2);  // &lt; 0  </p>
<p>Optionals </p>
<p>Optional不是一个函数式接口，而是一个精巧的工具接口，用来防止NullPointerEception产生。这个概念在下一节会显得很重要，所以我们在这里快速地浏览一下Optional的工作原理。 </p>
<p>Optional是一个简单的值容器，这个值可以是null，也可以是non-null。考虑到一个方法可能会返回一个non-null的值，也可能返回一个空值。为了不直接返回null，我们在Java 8中就返回一个Optional。 </p>
<p>Java代码<br>Optional<string> optional = Optional.of(“bam”);  </string></p>
<p>optional.isPresent();           // true<br>optional.get();                 // “bam”<br>optional.orElse(“fallback”);    // “bam”  </p>
<p>optional.ifPresent((s) -&gt; System.out.println(s.charAt(0)));     // “b”  </p>
<p>Streams Top<br>java.util.Stream表示了某一种元素的序列，在这些元素上可以进行各种操作。Stream操作可以是中间操作，也可以是完结操作。完结操作 会返回一个某种类型的值，而中间操作会返回流对象本身，并且你可以通过多次调用同一个流操作方法来将操作结果串起来（就像StringBuffer的 append方法一样————译者注）。Stream是在一个源的基础上创建出来的，例如java.util.Collection中的list或者 set（map不能作为Stream的源）。Stream操作往往可以通过顺序或者并行两种方式来执行。 </p>
<p>我们先了解一下序列流。首先，我们通过string类型的list的形式创建示例数据： </p>
<p>Java代码<br>List<string> stringCollection = new ArrayList&lt;&gt;();<br>stringCollection.add(“ddd2”);<br>stringCollection.add(“aaa2”);<br>stringCollection.add(“bbb1”);<br>stringCollection.add(“aaa1”);<br>stringCollection.add(“bbb3”);<br>stringCollection.add(“ccc”);<br>stringCollection.add(“bbb2”);<br>stringCollection.add(“ddd1”);  </string></p>
<p>Java 8中的Collections类的功能已经有所增强，你可以之直接通过调用Collections.stream()或者Collection.parallelStream()方法来创建一个流对象。下面的章节会解释这个最常用的操作。 </p>
<p>Filter </p>
<p>Filter接受一个predicate接口类型的变量，并将所有流对象中的元素进行过滤。该操作是一个中间操作，因此它允许我们在返回结果的基 础上再进行其他的流操作（forEach）。ForEach接受一个function接口类型的变量，用来执行对每一个元素的操作。ForEach是一个 中止操作。它不返回流，所以我们不能再调用其他的流操作。 </p>
<p>Java代码<br>stringCollection<br>    .stream()<br>    .filter((s) -&gt; s.startsWith(“a”))<br>    .forEach(System.out::println);  </p>
<p>// “aaa2”, “aaa1”  </p>
<p>Sorted </p>
<p>Sorted是一个中间操作，能够返回一个排过序的流对象的视图。流对象中的元素会默认按照自然顺序进行排序，除非你自己指定一个Comparator接口来改变排序规则。 </p>
<p>Java代码<br>stringCollection<br>    .stream()<br>    .sorted()<br>    .filter((s) -&gt; s.startsWith(“a”))<br>    .forEach(System.out::println);  </p>
<p>// “aaa1”, “aaa2”  </p>
<p>一定要记住，sorted只是创建一个流对象排序的视图，而不会改变原来集合中元素的顺序。原来string集合中的元素顺序是没有改变的。 </p>
<p>Java代码<br>System.out.println(stringCollection);<br>// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1  </p>
<p>Map </p>
<p>map是一个对于流对象的中间操作，通过给定的方法，它能够把流对象中的每一个元素对应到另外一个对象上。下面的例子就演示了如何把每个 string都转换成大写的string. 不但如此，你还可以把每一种对象映射成为其他类型。对于带泛型结果的流对象，具体的类型还要由传递给map的泛型方法来决定。 </p>
<p>Java代码<br>stringCollection<br>    .stream()<br>    .map(String::toUpperCase)<br>    .sorted((a, b) -&gt; b.compareTo(a))<br>    .forEach(System.out::println);  </p>
<p>// “DDD2”, “DDD1”, “CCC”, “BBB3”, “BBB2”, “AAA2”, “AAA1”  </p>
<p>Match </p>
<p>匹配操作有多种不同的类型，都是用来判断某一种规则是否与流对象相互吻合的。所有的匹配操作都是终结操作，只返回一个boolean类型的结果。 </p>
<p>Java代码<br>boolean anyStartsWithA =<br>    stringCollection<br>        .stream()<br>        .anyMatch((s) -&gt; s.startsWith(“a”));  </p>
<p>System.out.println(anyStartsWithA);      // true  </p>
<p>boolean allStartsWithA =<br>    stringCollection<br>        .stream()<br>        .allMatch((s) -&gt; s.startsWith(“a”));  </p>
<p>System.out.println(allStartsWithA);      // false  </p>
<p>boolean noneStartsWithZ =<br>    stringCollection<br>        .stream()<br>        .noneMatch((s) -&gt; s.startsWith(“z”));  </p>
<p>System.out.println(noneStartsWithZ);      // true  </p>
<p>Count </p>
<p>Count是一个终结操作，它的作用是返回一个数值，用来标识当前流对象中包含的元素数量。 </p>
<p>Java代码<br>long startsWithB =<br>    stringCollection<br>        .stream()<br>        .filter((s) -&gt; s.startsWith(“b”))<br>        .count();  </p>
<p>System.out.println(startsWithB);    // 3  </p>
<p>Reduce </p>
<p>该操作是一个终结操作，它能够通过某一个方法，对元素进行削减操作。该操作的结果会放在一个Optional变量里返回。 </p>
<p>Java代码<br>Optional<string> reduced =<br>    stringCollection<br>        .stream()<br>        .sorted()<br>        .reduce((s1, s2) -&gt; s1 + “#” + s2);  </string></p>
<p>reduced.ifPresent(System.out::println);<br>// “aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2”  </p>
<p>Parallel Streams Top<br>像上面所说的，流操作可以是顺序的，也可以是并行的。顺序操作通过单线程执行，而并行操作则通过多线程执行。 </p>
<p>下面的例子就演示了如何使用并行流进行操作来提高运行效率，代码非常简单。 </p>
<p>首先我们创建一个大的list，里面的元素都是唯一的： </p>
<p>Java代码<br>int max = 1000000;<br>List<string> values = new ArrayList&lt;&gt;(max);<br>for (int i = 0; i &lt; max; i++) {<br>    UUID uuid = UUID.randomUUID();<br>    values.add(uuid.toString());<br>}  </string></p>
<p>现在，我们测量一下对这个集合进行排序所使用的时间。 </p>
<p>顺序排序 </p>
<p>Java代码<br>long t0 = System.nanoTime();  </p>
<p>long count = values.stream().sorted().count();<br>System.out.println(count);  </p>
<p>long t1 = System.nanoTime();  </p>
<p>long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);<br>System.out.println(String.format(“sequential sort took: %d ms”, millis));  </p>
<p>// sequential sort took: 899 ms  </p>
<p>并行排序 </p>
<p>Java代码<br>long t0 = System.nanoTime();  </p>
<p>long count = values.parallelStream().sorted().count();<br>System.out.println(count);  </p>
<p>long t1 = System.nanoTime();  </p>
<p>long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);<br>System.out.println(String.format(“parallel sort took: %d ms”, millis));  </p>
<p>// parallel sort took: 472 ms  </p>
<p>如你所见，所有的代码段几乎都相同，唯一的不同就是把stream()改成了parallelStream(), 结果并行排序快了50%。 </p>
<p>Map Top<br>正如前面已经提到的那样，map是不支持流操作的。而更新后的map现在则支持多种实用的新方法，来完成常规的任务。 </p>
<p>Java代码<br>Map<integer, string=""> map = new HashMap&lt;&gt;();  </integer,></p>
<p>for (int i = 0; i &lt; 10; i++) {<br>    map.putIfAbsent(i, “val” + i);<br>}  </p>
<p>map.forEach((id, val) -&gt; System.out.println(val));  </p>
<p>上面的代码风格是完全自解释的：putIfAbsent避免我们将null写入；forEach接受一个消费者对象，从而将操作实施到每一个map中的值上。 </p>
<p>下面的这个例子展示了如何使用函数来计算map的编码： </p>
<p>Java代码<br>map.computeIfPresent(3, (num, val) -&gt; val + num);<br>map.get(3);             // val33  </p>
<p>map.computeIfPresent(9, (num, val) -&gt; null);<br>map.containsKey(9);     // false  </p>
<p>map.computeIfAbsent(23, num -&gt; “val” + num);<br>map.containsKey(23);    // true  </p>
<p>map.computeIfAbsent(3, num -&gt; “bam”);<br>map.get(3);             // val33  </p>
<p>接下来，我们将学习，当给定一个key值时，如何把一个实例从对应的key中移除： </p>
<p>Java代码<br>map.remove(3, “val3”);<br>map.get(3);             // val33  </p>
<p>map.remove(3, “val33”);<br>map.get(3);             // null  </p>
<p>另一个有用的方法： </p>
<p>Java代码<br>map.getOrDefault(42, “not found”);  // not found  </p>
<p>将map中的实例合并也是非常容易的： </p>
<p>Java代码<br>map.merge(9, “val9”, (value, newValue) -&gt; value.concat(newValue));<br>map.get(9);             // val9  </p>
<p>map.merge(9, “concat”, (value, newValue) -&gt; value.concat(newValue));<br>map.get(9);             // val9concat  </p>
<p>合并操作先看map中是否没有特定的key/value存在，如果是，则把key/value存入map，否则merging函数就会被调用，对现有的数值进行修改。 </p>
<p>时间日期API Top<br>Java 8 包含了全新的时间日期API，这些功能都放在了java.time包下。新的时间日期API是基于Joda-Time库开发的，但是也不尽相同。下面的例子就涵盖了大多数新的API的重要部分。 </p>
<p>Clock </p>
<p>Clock提供了对当前时间和日期的访问功能。Clock是对当前时区敏感的，并可用于替代 System.currentTimeMillis()方法来获取当前的毫秒时间。当前时间线上的时刻可以用Instance类来表示。Instance 也能够用于创建原先的java.util.Date对象。 </p>
<p>Java代码<br>Clock clock = Clock.systemDefaultZone();<br>long millis = clock.millis();  </p>
<p>Instant instant = clock.instant();<br>Date legacyDate = Date.from(instant);   // legacy java.util.Date  </p>
<p>Timezones </p>
<p>时区类可以用一个ZoneId来表示。时区类的对象可以通过静态工厂方法方便地获取。时区类还定义了一个偏移量，用来在当前时刻或某时间与目标时区时间之间进行转换。 </p>
<p>Java代码<br>System.out.println(ZoneId.getAvailableZoneIds());<br>// prints all available timezone ids  </p>
<p>ZoneId zone1 = ZoneId.of(“Europe/Berlin”);<br>ZoneId zone2 = ZoneId.of(“Brazil/East”);<br>System.out.println(zone1.getRules());<br>System.out.println(zone2.getRules());  </p>
<p>// ZoneRules[currentStandardOffset=+01:00]<br>// ZoneRules[currentStandardOffset=-03:00]  </p>
<p>LocalTime </p>
<p>本地时间类表示一个没有指定时区的时间，例如，10 p.m.或者17：30:15，下面的例子会用上面的例子定义的时区创建两个本地时间对象。然后我们会比较两个时间，并计算它们之间的小时和分钟的不同。 </p>
<p>Java代码<br>LocalTime now1 = LocalTime.now(zone1);<br>LocalTime now2 = LocalTime.now(zone2);  </p>
<p>System.out.println(now1.isBefore(now2));  // false  </p>
<p>long hoursBetween = ChronoUnit.HOURS.between(now1, now2);<br>long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);  </p>
<p>System.out.println(hoursBetween);       // -3<br>System.out.println(minutesBetween);     // -239  </p>
<p>LocalTime是由多个工厂方法组成，其目的是为了简化对时间对象实例的创建和操作，包括对时间字符串进行解析的操作。 </p>
<p>Java代码<br>LocalTime late = LocalTime.of(23, 59, 59);<br>System.out.println(late);       // 23:59:59  </p>
<p>DateTimeFormatter germanFormatter =<br>    DateTimeFormatter<br>        .ofLocalizedTime(FormatStyle.SHORT)<br>        .withLocale(Locale.GERMAN);  </p>
<p>LocalTime leetTime = LocalTime.parse(“13:37”, germanFormatter);<br>System.out.println(leetTime);   // 13:37  </p>
<p>LocalDate </p>
<p>本地时间表示了一个独一无二的时间，例如：2014-03-11。这个时间是不可变的，与LocalTime是同源的。下面的例子演示了如何通过加减日，月，年等指标来计算新的日期。记住，每一次操作都会返回一个新的时间对象。 </p>
<p>Java代码<br>LocalDate today = LocalDate.now();<br>LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);<br>LocalDate yesterday = tomorrow.minusDays(2);  </p>
<p>LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);<br>DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();<br>System.out.println(dayOfWeek);    // FRIDAY<span style="font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif; font-size: 13px; line-height: 19px;">Parsing a LocalDate from a string is just as simple as parsing a LocalTime:</span>  </p>
<p>解析字符串并形成LocalDate对象，这个操作和解析LocalTime一样简单。 </p>
<p>Java代码<br>DateTimeFormatter germanFormatter =<br>    DateTimeFormatter<br>        .ofLocalizedDate(FormatStyle.MEDIUM)<br>        .withLocale(Locale.GERMAN);  </p>
<p>LocalDate xmas = LocalDate.parse(“24.12.2014”, germanFormatter);<br>System.out.println(xmas);   // 2014-12-24  </p>
<p>LocalDateTime </p>
<p>LocalDateTime表示的是日期-时间。它将刚才介绍的日期对象和时间对象结合起来，形成了一个对象实例。LocalDateTime是不可变的，与LocalTime和LocalDate的工作原理相同。我们可以通过调用方法来获取日期时间对象中特定的数据域。 </p>
<p>Java代码<br>LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);  </p>
<p>DayOfWeek dayOfWeek = sylvester.getDayOfWeek();<br>System.out.println(dayOfWeek);      // WEDNESDAY  </p>
<p>Month month = sylvester.getMonth();<br>System.out.println(month);          // DECEMBER  </p>
<p>long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);<br>System.out.println(minuteOfDay);    // 1439  </p>
<p>如果再加上的时区信息，LocalDateTime能够被转换成Instance实例。Instance能够被转换成以前的java.util.Date对象。 </p>
<p>Java代码<br>Instant instant = sylvester<br>        .atZone(ZoneId.systemDefault())<br>        .toInstant();  </p>
<p>Date legacyDate = Date.from(instant);<br>System.out.println(legacyDate);     // Wed Dec 31 23:59:59 CET 2014  </p>
<p>格式化日期-时间对象就和格式化日期对象或者时间对象一样。除了使用预定义的格式以外，我们还可以创建自定义的格式化对象，然后匹配我们自定义的格式。 </p>
<p>Java代码<br>DateTimeFormatter formatter =<br>    DateTimeFormatter<br>        .ofPattern(“MMM dd, yyyy - HH:mm”);  </p>
<p>LocalDateTime parsed = LocalDateTime.parse(“Nov 03, 2014 - 07:13”, formatter);<br>String string = formatter.format(parsed);<br>System.out.println(string);     // Nov 03, 2014 - 07:13  </p>
<p>不同于java.text.NumberFormat，新的DateTimeFormatter类是不可变的，也是线程安全的。 </p>
<p>更多的细节，请看这里 </p>
<p>Annotations Top<br>Java 8中的注解是可重复的。让我们直接深入看看例子，弄明白它是什么意思。 </p>
<p>首先，我们定义一个包装注解，它包括了一个实际注解的数组 </p>
<p>Java代码<br>@interface Hints {<br>    Hint[] value();<br>}  </p>
<p>@Repeatable(Hints.class)<br>@interface Hint {<br>    String value();<br>}  </p>
<p>只要在前面加上注解名：@Repeatable，Java 8 允许我们对同一类型使用多重注解： </p>
<p>变体1：使用注解容器（老方法）： </p>
<p>Java代码<br>@Hints({@Hint(“hint1”), @Hint(“hint2”)})<br>class Person {}  </p>
<p>变体2：使用可重复注解（新方法）： </p>
<p>Java代码<br>@Hint(“hint1”)<br>@Hint(“hint2”)<br>class Person {}  </p>
<p>使用变体2，Java编译器能够在内部自动对@Hint进行设置。这对于通过反射来读取注解信息来说，是非常重要的。 </p>
<p>Java代码<br>Hint hint = Person.class.getAnnotation(Hint.class);<br>System.out.println(hint);                   // null  </p>
<p>Hints hints1 = Person.class.getAnnotation(Hints.class);<br>System.out.println(hints1.value().length);  // 2  </p>
<p>Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);<br>System.out.println(hints2.length);          // 2  </p>
<p>尽管我们绝对不会在Person类上声明@Hints注解，但是它的信息仍然可以通过getAnnotation(Hints.class)来读 取。并且，getAnnotationsByType方法会更方便，因为它赋予了所有@Hints注解标注的方法直接的访问权限。 </p>
<p>Java代码<br>@Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})<br>@interface MyAnnotation {}  </p>
<p>总结 Top<br>Java 8编程指南就到此告一段落。当然，还有很多内容需要进一步研究和说明。这就需要靠读者您来对JDK 8进行探究了，例如：Arrays.parallelSort, StampedLock和CompletableFuture等等 ———— 我这里只是举几个例子而已。 </p>
<p>我希望这个博文能够对您有所帮助，也希望您阅读愉快。完整的教程源代码放在了GitHub上。您可以尽情地fork，并请通过Twitter告诉我您的反馈。 </p>
<p>原文链接： winterbe 翻译： ImportNew.com - 黄小非 </p>
<h2 id="译文链接：-http-www-importnew-com-10360-html"><a href="#译文链接：-http-www-importnew-com-10360-html" class="headerlink" title="译文链接： http://www.importnew.com/10360.html"></a>译文链接： <a href="http://www.importnew.com/10360.html" target="_blank" rel="noopener">http://www.importnew.com/10360.html</a></h2><p>加快OpenJDK的开发速度：继2014年3月份发布了Java 8之后，我们进入下一个两年的发布周期。 Java 9预计在2016年发布，并且已经公布了JEP(JDK改进提议)中的前期列表。同时，我们已经把一些新特性整理到了JSR(Java规范请求)，还有提 出了一些希望包括在新版本中的其他特性。</p>
<p>这些重要的特性都包括在Jigsaw项目中。显著的性能改善和期待已久的API包括：进程API更新，JSON将成为java.util的一部分，货币处理API对于想处在技术最前沿的你，可从这里获得Java 9的初期版本。</p>
<p>被接受的特性</p>
<ol>
<li>Jigsaw 项目;模块化源码</li>
</ol>
<p>Jigsaw项目是为了模块化Java代码、将JRE分成可相互协作的组件，这也是Java 9 众多特色种的一个。JEP是迈向Jigsaw四步中的第一步，它不会改变JRE和JDK的真实结构。JEP是为了模块化JDK源代码，让编译系统能够模块 编译并在构建时检查模块边界。这个项目原本是随Java 8发布的，但由于推迟，所以将把它加到Java 9.</p>
<p>一旦它完成，它可能允许根据一个项目需求自定义组件从而减少rt.jar的大小。在JDK 7 和JDK 8的rt.jar包中有大约20,000个类，但有很多类在一些特定的环境里面并没有被用到(即使在Java 8的紧凑分布特性中已经包含了一部分解决方法也存在着类冗余)。这么做是为了能让Java能够容易应用到小型计算设备(比如网络设备)中，提高它的安全和 性能，同时也能让开发者更容易构建和维护这些类库。</p>
<ol>
<li>简化进程API </li>
</ol>
<p>截止到目前，Java控制与管理系统进程的能力是有限的。举个例子，现在为了简便获取你程序的进程PID，你要么调用本地程序要么要自己使用一些变通方案。更多的是，每个（系统）平台需要有一个不同实现来确保你能获得正确的结果。 </p>
<p>期望代码能获取Linux PIDS，现在是如下方式： </p>
<p>在Java 9中，可以变换成如下方式（支持所有的操作系统）： </p>
<p>这次更新将会扩展Java与操作系统的交互能力：新增一些新的直接明了的方法去处理PIDs，进程名字和状态以及枚举多个JVM和进程以及更多事情。 </p>
<ol>
<li>轻量级 JSON API </li>
</ol>
<p>目前有多种处理JSON的Java工具，但JSON API 独到之处在于JSON API将作为Java语言的一部分，轻量并且运用Java 8的新特性。它将放在java.util包里一起发布(但在JSR 353里面的JSON是用第三方包或者其他的方法处理的). </p>
<ol>
<li>钱和货币的API </li>
</ol>
<p>在Java 8引进了日期和时间的API之后, Java 9引入了新的货币API, 用以表示货币, 支持币种之间的转换和各种复杂运算. 关于这个项目的具体情况, 请访问<a href="https://github.com/JavaMoney,里面已经给出了使用说明和示例" target="_blank" rel="noopener">https://github.com/JavaMoney,里面已经给出了使用说明和示例</a>, 以下是几个重要的例子: </p>
<p>更多关于 JSR 354的内容 </p>
<ol>
<li>改善锁争用机制</li>
</ol>
<p>锁争用是限制许多Java多线程应用性能的瓶颈. 新的机制在改善Java对象监视器的性能方面已经得到了多种基准(benchmark)的验证, 其中包括Volano. 测试中通讯服务器开放了海量的进程来连接客户端, 其中有很多连接都申请同一个资源, 以此模拟重负荷日常应用.</p>
<p>通过诸如此类的压力测试我们可以估算JVM的极限吞吐量(每秒的消息数量). JEP在22种不同的测试中都得到了出色的成绩, 新的机制如果能在Java 9中得到应用的话, 应用程序的性能将会大大提升.</p>
<p>关于JEP 143的更多内容 </p>
<ol>
<li>代码分段缓存</li>
</ol>
<p>Java 9的另一个性能提升来自于JIT(Just-in-time)编译器. 当某段代码被大量重复执行的时候, 虚拟机会把这段代码编译成机器码(native code)并储存在代码缓存里面, 进而通过访问缓存中不同分段的代码来提升编译器的效率.</p>
<p>和原来的单一缓存区域不同的是, 新的代码缓存根据代码自身的生命周期而分为三种:</p>
<p>永驻代码(JVM 内置 / 非方法代码)<br>短期代码(仅在某些条件下适用的配置性(profiled)代码)<br>长期代码(非配置性代码)<br>缓存分段会在各个方面提升程序的性能, 比如做垃圾回收扫描的时候可以直接跳过非方法代码(永驻代码), 从而提升效率.</p>
<p>更多关于JEP 197的内容 </p>
<ol>
<li>智能Java编译, 第二阶段</li>
</ol>
<p>智能Java编译工具sjavac的第一阶段开始于JEP 139这个项目, 用于在多核处理器上提升JDK的编译速度. 现在这个项目已经进入第二阶段(JEP 199), 目的是改进sjavac并让其成为取代目前JDK编译工具javac的Java默认的通用编译工具.</p>
<p>其他值得期待的内容:</p>
<ol>
<li>HTTP 2.0客户端</li>
</ol>
<p>HTTP 2.0标准虽然还没正式发布, 但是已经进入了最终审查阶段, 预计可以在Java 9发布之前审查完毕. JEP 110将会重新定义并实现一个全新的Java HTTP客户端, 用来取代现在的HttpURLConnection, 同时也会实现HTTP 2.0和网络接口(原文websockets). 它现在还没被JEP正式认可但我们希望在Java 9中包含这一项目的内容.</p>
<p>官方的HTTP 2.0 RFC(Request for Comments, 官方技术讨论/会议记录等等的一系列文档记录)预订于2015年2月发布, 它是基于Google发布的SPDY(Speedy, 快速的)协议. 基于SPDY协议的网络相对于基于HTTP 1.1协议的网络有11.81%到47.7%之间的显著提速, 现在已经有浏览器实现了这个协议.</p>
<ol>
<li>Kulla计划: Java的REPL实现</li>
</ol>
<p>这个取名为Kulla的项目最近宣布将于2015年4月整合测试, 虽然已经不太有希望能赶上Java 9的发布, 但如果进度快的话或许刚好能赶上. 现在Java并没有来自官方的REPL(Read-Eval-Print-Loop)方式, 也就是说现在如果你想要跑几行Java代码做一个快速的测试, 你仍然需要把这几行代码封装在项目或者方法里面. 虽然在一些流行的IDE里面有Java REPL工具, 但它们并没有官方支持, 而Kulla项目或许就能成为Java官方发布的REPL解决方案. </p>

      
    </div>
    
    
    
	
	<div>  <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">------本文结束  感谢阅读------</div>
    
</div> </div>

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="http://githubimg.lushunde.com/gzh.jpg" alt="鲁顺德 wechat" style="width: 200px; max-width: 100%;"/>
    <div>欢迎您扫一扫上面的微信公众号，订阅我的分享资源！</div>
</div>

      </div>
    

	
    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="http://githubimg.lushunde.com/wx.jpg" alt="鲁顺德 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="http://githubimg.lushunde.com/zfb.jpg" alt="鲁顺德 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JDK新特性/" rel="tag"><i class="fa fa-tag"></i> JDK新特性</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/13/centos7-安装-nginx-TCP-HTTP/" rel="next" title="Centos7 安装 Nginx TCP HTTP">
                <i class="fa fa-chevron-left"></i> Centos7 安装 Nginx TCP HTTP
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/07/08/redis一主二从-哨兵模式/" rel="prev" title="Redis一主二从+哨兵模式">
                Redis一主二从+哨兵模式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="uyan_frame"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://githubimg.lushunde.com/head.png"
                alt="鲁顺德" />
            
              <p class="site-author-name" itemprop="name">鲁顺德</p>
              <p class="site-description motion-element" itemprop="description">未来不可预期，才会期待和精彩。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/lushunde321" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:lushunde321@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://blog.csdn.net/xiaoyu19910321" title="CSDN" target="_blank">CSDN</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://github.com/lushunde321/" title="GitHub" target="_blank">GitHub</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JDK-1-0"><span class="nav-number">1.</span> <span class="nav-text">JDK 1.0</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDK-1-1"><span class="nav-number">2.</span> <span class="nav-text">JDK 1.1</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDK-1-2"><span class="nav-number">3.</span> <span class="nav-text">JDK 1.2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDK-1-3"><span class="nav-number">4.</span> <span class="nav-text">JDK 1.3</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDK-1-4"><span class="nav-number">5.</span> <span class="nav-text">JDK 1.4</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDK-5-0"><span class="nav-number">6.</span> <span class="nav-text">JDK 5.0</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDK-6-0"><span class="nav-number">7.</span> <span class="nav-text">JDK 6.0</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDK-7-0"><span class="nav-number">8.</span> <span class="nav-text">JDK 7.0</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDK-8-0"><span class="nav-number">9.</span> <span class="nav-text">JDK 8.0</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDK-9-0"><span class="nav-number">10.</span> <span class="nav-text">JDK 9.0</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDK-10"><span class="nav-number">11.</span> <span class="nav-text">JDK 10</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#——————————————————————"><span class="nav-number">11.1.</span> <span class="nav-text">——————————————————————-</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK1-5新特性："><span class="nav-number">11.2.</span> <span class="nav-text">JDK1.5新特性：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-自动装箱与拆箱："><span class="nav-number">11.2.0.1.</span> <span class="nav-text">1.自动装箱与拆箱：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-枚举-常用来设计单例模式"><span class="nav-number">11.2.0.2.</span> <span class="nav-text">2.枚举(常用来设计单例模式)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-静态导入"><span class="nav-number">11.2.0.3.</span> <span class="nav-text">3.静态导入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-可变参数"><span class="nav-number">11.2.0.4.</span> <span class="nav-text">4.可变参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-内省"><span class="nav-number">11.2.0.5.</span> <span class="nav-text">5.内省</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jdk1-6新特性："><span class="nav-number">11.3.</span> <span class="nav-text">jdk1.6新特性：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">11.3.1.</span> <span class="nav-text">Happy New Year 2007!–Chinajash</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#译文链接：-http-www-importnew-com-10360-html"><span class="nav-number">11.4.</span> <span class="nav-text">译文链接： http://www.importnew.com/10360.html</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>

  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">鲁顺德</span>

  
<!--- 换行代码
  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">43.1k</span>
  
</div>
-->
<!-- 隐藏底部的代码
 
  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>



-->

<div class="theme-info">
  <div class="with-love"><i class="fa fa-file-word-o"></i></div>
  <span class="post-count">博客全站共43.1k字</span>
</div>
        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 本站访客
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 本站访问
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  
    

    
      <!-- UY BEGIN -->
      <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2159493"></script>
      <!-- UY END -->
    
  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
